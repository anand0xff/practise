# line-by-line explanation:

Developer D:
git checkout -b dev # create branch locally and switch to it
#DT created dev branch locally.

# added content to cmdline.txt
add, commit, then: git push origin dev  # git push <remote> <branch>

Developer A:
$ git pull origin dev   FAILED: 
        error: Your local changes to the following files would be overwritten by merge:
$ git checkout cmdline.txt  # re-fetch the repo's file
$ git pull origin dev  
A & D local are synched.

-------------
#git branch -[rla] helpful
 git branch --list
        * master
$ git checkout dev
Branch 'dev' set up to track remote branch 'dev' from 'origin'.
Switched to a new branch 'dev'
$ gs
origin	https://github.com/anand0xff/practise.git (fetch)
origin	https://github.com/anand0xff/practise.git (push)
commit 2f4ed9a9bef163c4e645892ced86265a0e7acb45
Author: Developer D <devd@inst.org>
Date:   Tue Jan 28 10:04:12 2020 -0500

On branch dev
Your branch is up to date with 'origin/dev'.

nothing to commit, working tree clean
-------------
$ git push origin dev

Developer D:
$ git pull origin dev

Branch dev on the local repo of D is in sync with the remote branch dev.
changed cmdline.txt, pushed to origin/dev

Developer A:
$ git diff dev origin/dev  # doesn't show differences
$ git fetch origin
$ git diff dev origin/dev  # shows differences
$ git merge  # merged the fetched changes to local dev file.

$ git branch --list
$ git checkout dev  # switch to branch dev


Note on FETCH (https://stackoverflow.com/questions/35591887/how-to-undo-git-fetch):

    Let's assume that you have your origin remote and your local develop branch
    is based on master, but your local master is behind origin/master (but you
    don't see it yet, because you haven't fetched origin yet).

    So performing git fetch will add new commits from origin/master and tags to
    your local repo. In some cases you don't want to see those new commits at
    all and they will reduce readability of your history.

    Having said that, you can "undo" git fetch by doing:

  git update-ref refs/remotes/origin/master refs/remotes/origin/master@{1}



All this does is changes the origin/master pointer to the previous state. Maybe you'll have to play with {n} a bit to get the exact state, but in general it may help.

Developer A:
$ git checkout -b adev origin/dev  # create branch adev off <<origin>>/dev, switch to it
add stuff to adev; commit; push
  832  git add cmdline.txt 
  833  git commit -m "A changes to cmdline"
  834  git push  
       | fatal: The upstream branch of your current branch does not match
       | the name of your current branch.  To push to the upstream branch
       | on the remote, use
       |     git push origin HEAD:dev
       | To push to the branch of the same name on the remote, use
       |     git push origin adev
  835  git push origin adev
       | remote: Create a pull request for 'adev' on GitHub by visiting:
       | remote:      https://github.com/anand0xff/practise/pull/new/adev

<---

$ git checkout -b ddev origin/dev  # create branch ddev off branch <<origin>>/dev locally, switch to it
add stuff to bdev; commit; push


------
Developer D:
Create PR for merge of ddev , 
Developer A merges successfully, 
D deletes dev/ddev on github
Developer A and Developer D locally: 
$ git branch --all
* adev
  dev
  master
  remotes/origin/HEAD -> origin/master
  remotes/origin/adev
  remotes/origin/ddev
  remotes/origin/dev
  remotes/origin/master
$ git remote prune origin
$ git branch --all
* adev
  dev
  master
  remotes/origin/HEAD -> origin/master
  remotes/origin/adev
  remotes/origin/dev
  remotes/origin/master
